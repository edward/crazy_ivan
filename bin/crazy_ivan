#!/usr/bin/env ruby

begin
  require 'crazy_ivan'
rescue LoadError
  # If people are not using gems, the load path must still
  # be correct.
  # TODO: Remove the begin / rescue block somehow
  $LOAD_PATH.unshift File.dirname(__FILE__) + '/../lib'
  retry
end

require "optparse"
require "logger"

Syslog.open('crazy_ivan', Syslog::LOG_PID | Syslog::LOG_CONS)

Signal.trap("INT") do
  Syslog.debug("Interrupted - Now dropping a note in the test output and exiting.")
  CrazyIvan.interrupt_test
  CrazyIvan::ProcessManager.unlock
  puts
  exit
end

def show_howto
  puts "Hankering for a continuous integration server, eh?"
  puts
  puts "1. Jump over to where you want to keep your projects"
  puts "   and git clone or svn checkout or whatever-them down:"
  puts "     $ mkdir -p /var/continuous-integration/projects/"
  puts "     $ cd /var/continuous-integration/projects"
  puts "     $ git clone git@github.com:edward/active_merchant.git"
  puts
  puts "2. Run:"
  puts "     $ crazy_ivan setup"
  puts
  puts "3. Run it manually to check that everything is ok:"
  puts "     $ crazy_ivan /var/www/ci"
  puts
  puts "   (/var/www/ci should be accessible through your web server)"
  puts "   Check /var/www/ci/index.html through a web browser."
  puts
  puts "4. Set up cron to run it every 15 minutes:"
  puts "     $ echo \"0,15,30,45 * * * * cd /var/continuous-integration; crazy_ivan /var/www/ci\" > ci.cron"
  puts "     $ crontab ci.cron"
  puts
  puts "5. Profit."
  puts
  puts "Please see http://github.com/edward/crazy_ivan for more."
end

options = {}


class CrazyIvan::ProcessManager
  PidFile = '/tmp/crazy_ivan.pid'
  
  def self.acquire_lock
    lock_exclusively!
    yield
  end
  
  def self.unlock
    File.new(PidFile).flock(File::LOCK_UN)
  end

  def self.ci_already_running?
    File.exists?(PidFile) && !File.new(PidFile).flock(File::LOCK_EX | File::LOCK_NB)
  end
  
  def self.lock_exclusively!(options = {})
    pid = Integer(File.read(PidFile)) if File.exists?(PidFile)
    
    if options[:interrupt_existing_process]
      File.open(PidFile, "w+") { |fp| fp << Process.pid }

      if ci_already_running?
        Process.kill("INT", pid)
        Syslog.debug("Detected another running CI process #{pid}; interrupting it and starting myself")
        File.new(PidFile).flock(File::LOCK_EX)
      end
    else
      if ci_already_running?
        msg = "Detected another running CI process #{pid} - terminating myself"
        Syslog.warning msg
        puts msg
        Process.kill("INT", 0)
      else
        File.open(PidFile, "w+") { |fp| fp << Process.pid }
        File.new(PidFile).flock(File::LOCK_EX)
      end
    end
  end
end

ARGV.options do |opts|
  opts.banner = "Usage:  #{File.basename($PROGRAM_NAME)} test_reports_path"
  
  opts.on_tail("-h", "--help", "Show this message") do
    show_howto
    puts opts
    exit
  end

  opts.on_tail("--version", "Show version") do
    puts CrazyIvan::VERSION
    exit
  end
  
  begin
    opts.parse!
        
    case ARGV[0]
    when /setup/
      CrazyIvan::setup
    when /\w+/  # a directory for test results
      Syslog.debug "Acquiring lock"
      CrazyIvan::ProcessManager.acquire_lock do
        Syslog.debug "Generating reports in #{ARGV[0]}"
        CrazyIvan::generate_test_reports_in(ARGV[0])
      end
    else
      show_howto
      exit
    end
  end
end

